// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/public/interfaces/bindings/mojom_types.mojom
//

package mojom_types

import (
	"fmt"
	"mojo/public/go/bindings"
	"sort"
)

// These IDs are the Mojom Identifiers / Type Keys.
// Mojom libraries importing this one will use these identifiers when building
// TypeReference objects.
var ID_mojom_types_SimpleType__ string = "mojom_types_SimpleType__"
var ID_mojom_types_BuiltinConstantValue__ string = "mojom_types_BuiltinConstantValue__"
var ID_mojom_types_Kind__ string = "mojom_types_Kind__"
var ID_mojom_types_StringType__ string = "mojom_types_StringType__"
var ID_mojom_types_HandleType__ string = "mojom_types_HandleType__"
var ID_mojom_types_ArrayType__ string = "mojom_types_ArrayType__"
var ID_mojom_types_MapType__ string = "mojom_types_MapType__"
var ID_mojom_types_TypeReference__ string = "mojom_types_TypeReference__"
var ID_mojom_types_StructField__ string = "mojom_types_StructField__"
var ID_mojom_types_DefaultKeyword__ string = "mojom_types_DefaultKeyword__"
var ID_mojom_types_StructVersion__ string = "mojom_types_StructVersion__"
var ID_mojom_types_MojomStruct__ string = "mojom_types_MojomStruct__"
var ID_mojom_types_UnionField__ string = "mojom_types_UnionField__"
var ID_mojom_types_MojomUnion__ string = "mojom_types_MojomUnion__"
var ID_mojom_types_EnumValue__ string = "mojom_types_EnumValue__"
var ID_mojom_types_MojomEnum__ string = "mojom_types_MojomEnum__"
var ID_mojom_types_MojomMethod__ string = "mojom_types_MojomMethod__"
var ID_mojom_types_MojomInterface__ string = "mojom_types_MojomInterface__"
var ID_mojom_types_UserValueReference__ string = "mojom_types_UserValueReference__"
var ID_mojom_types_DeclaredConstant__ string = "mojom_types_DeclaredConstant__"
var ID_mojom_types_DeclarationData__ string = "mojom_types_DeclarationData__"
var ID_mojom_types_SourceFileInfo__ string = "mojom_types_SourceFileInfo__"
var ID_mojom_types_ContainedDeclarations__ string = "mojom_types_ContainedDeclarations__"
var ID_mojom_types_Attribute__ string = "mojom_types_Attribute__"
var ID_mojom_types_Type__ string = "mojom_types_Type__"
var ID_mojom_types_UserDefinedType__ string = "mojom_types_UserDefinedType__"
var ID_mojom_types_DefaultFieldValue__ string = "mojom_types_DefaultFieldValue__"
var ID_mojom_types_Value__ string = "mojom_types_Value__"
var ID_mojom_types_LiteralValue__ string = "mojom_types_LiteralValue__"
var ID_mojom_types_UserDefinedValue__ string = "mojom_types_UserDefinedValue__"

var mojom_typesDesc__ = make(map[string]UserDefinedType)

func init() {
	mojom_typesDesc__["mojom_types_SimpleType__"] = &UserDefinedTypeEnumType{
		Value: mojom_types_SimpleType__(),
	}
	mojom_typesDesc__["mojom_types_BuiltinConstantValue__"] = &UserDefinedTypeEnumType{
		Value: mojom_types_BuiltinConstantValue__(),
	}
	mojom_typesDesc__["mojom_types_Kind__"] = &UserDefinedTypeEnumType{
		Value: mojom_types_Kind__(),
	}
	mojom_typesDesc__["mojom_types_StringType__"] = &UserDefinedTypeStructType{
		Value: mojom_types_StringType__(),
	}

	mojom_typesDesc__["mojom_types_HandleType__"] = &UserDefinedTypeStructType{
		Value: mojom_types_HandleType__(),
	}

	mojom_typesDesc__["mojom_types_ArrayType__"] = &UserDefinedTypeStructType{
		Value: mojom_types_ArrayType__(),
	}

	mojom_typesDesc__["mojom_types_Type__"] = &UserDefinedTypeUnionType{
		Value: mojom_types_Type__(),
	}

	mojom_typesDesc__["mojom_types_MapType__"] = &UserDefinedTypeStructType{
		Value: mojom_types_MapType__(),
	}

	mojom_typesDesc__["mojom_types_TypeReference__"] = &UserDefinedTypeStructType{
		Value: mojom_types_TypeReference__(),
	}

	mojom_typesDesc__["mojom_types_StructField__"] = &UserDefinedTypeStructType{
		Value: mojom_types_StructField__(),
	}
	mojom_typesDesc__["mojom_types_DeclarationData__"] = &UserDefinedTypeStructType{
		Value: mojom_types_DeclarationData__(),
	}

	mojom_typesDesc__["mojom_types_SourceFileInfo__"] = &UserDefinedTypeStructType{
		Value: mojom_types_SourceFileInfo__(),
	}

	mojom_typesDesc__["mojom_types_ContainedDeclarations__"] = &UserDefinedTypeStructType{
		Value: mojom_types_ContainedDeclarations__(),
	}

	mojom_typesDesc__["mojom_types_DefaultFieldValue__"] = &UserDefinedTypeUnionType{
		Value: mojom_types_DefaultFieldValue__(),
	}
	mojom_typesDesc__["mojom_types_Value__"] = &UserDefinedTypeUnionType{
		Value: mojom_types_Value__(),
	}
	mojom_typesDesc__["mojom_types_LiteralValue__"] = &UserDefinedTypeUnionType{
		Value: mojom_types_LiteralValue__(),
	}

	mojom_typesDesc__["mojom_types_UserValueReference__"] = &UserDefinedTypeStructType{
		Value: mojom_types_UserValueReference__(),
	}

	mojom_typesDesc__["mojom_types_DefaultKeyword__"] = &UserDefinedTypeStructType{
		Value: mojom_types_DefaultKeyword__(),
	}

	mojom_typesDesc__["mojom_types_StructVersion__"] = &UserDefinedTypeStructType{
		Value: mojom_types_StructVersion__(),
	}

	mojom_typesDesc__["mojom_types_MojomStruct__"] = &UserDefinedTypeStructType{
		Value: mojom_types_MojomStruct__(),
	}

	mojom_typesDesc__["mojom_types_UnionField__"] = &UserDefinedTypeStructType{
		Value: mojom_types_UnionField__(),
	}

	mojom_typesDesc__["mojom_types_MojomUnion__"] = &UserDefinedTypeStructType{
		Value: mojom_types_MojomUnion__(),
	}

	mojom_typesDesc__["mojom_types_EnumValue__"] = &UserDefinedTypeStructType{
		Value: mojom_types_EnumValue__(),
	}

	mojom_typesDesc__["mojom_types_MojomEnum__"] = &UserDefinedTypeStructType{
		Value: mojom_types_MojomEnum__(),
	}

	mojom_typesDesc__["mojom_types_MojomMethod__"] = &UserDefinedTypeStructType{
		Value: mojom_types_MojomMethod__(),
	}

	mojom_typesDesc__["mojom_types_MojomInterface__"] = &UserDefinedTypeStructType{
		Value: mojom_types_MojomInterface__(),
	}

	mojom_typesDesc__["mojom_types_DeclaredConstant__"] = &UserDefinedTypeStructType{
		Value: mojom_types_DeclaredConstant__(),
	}

	mojom_typesDesc__["mojom_types_Attribute__"] = &UserDefinedTypeStructType{
		Value: mojom_types_Attribute__(),
	}

	mojom_typesDesc__["mojom_types_UserDefinedType__"] = &UserDefinedTypeUnionType{
		Value: mojom_types_UserDefinedType__(),
	}

	mojom_typesDesc__["mojom_types_UserDefinedValue__"] = &UserDefinedTypeUnionType{
		Value: mojom_types_UserDefinedValue__(),
	}

}
func GetAllMojomTypeDefinitions() map[string]UserDefinedType {
	return mojom_typesDesc__
}

type SimpleType int32

const (
	SimpleType_Bool   = 0
	SimpleType_Double = SimpleType_Bool + 1
	SimpleType_Float  = SimpleType_Double + 1
	SimpleType_InT8   = SimpleType_Float + 1
	SimpleType_InT16  = SimpleType_InT8 + 1
	SimpleType_InT32  = SimpleType_InT16 + 1
	SimpleType_InT64  = SimpleType_InT32 + 1
	SimpleType_UinT8  = SimpleType_InT64 + 1
	SimpleType_UinT16 = SimpleType_UinT8 + 1
	SimpleType_UinT32 = SimpleType_UinT16 + 1
	SimpleType_UinT64 = SimpleType_UinT32 + 1
)

// String names and labels used by the MojomEnum types.
var (
	enumName_SimpleType             = "SimpleType"
	enumFieldName_SimpleType_Bool   = "Bool"
	enumFieldName_SimpleType_Double = "Double"
	enumFieldName_SimpleType_Float  = "Float"
	enumFieldName_SimpleType_InT8   = "InT8"
	enumFieldName_SimpleType_InT16  = "InT16"
	enumFieldName_SimpleType_InT32  = "InT32"
	enumFieldName_SimpleType_InT64  = "InT64"
	enumFieldName_SimpleType_UinT8  = "UinT8"
	enumFieldName_SimpleType_UinT16 = "UinT16"
	enumFieldName_SimpleType_UinT32 = "UinT32"
	enumFieldName_SimpleType_UinT64 = "UinT64"
)

func mojom_types_SimpleType__() MojomEnum {
	return MojomEnum{
		DeclData: &DeclarationData{
			ShortName: &enumName_SimpleType,
		},
		Values: []EnumValue{EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_SimpleType_Bool,
			},
			EnumTypeKey: ID_mojom_types_SimpleType__,
			IntValue:    int32(0),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_SimpleType_Double,
			},
			EnumTypeKey: ID_mojom_types_SimpleType__,
			IntValue:    int32(1),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_SimpleType_Float,
			},
			EnumTypeKey: ID_mojom_types_SimpleType__,
			IntValue:    int32(2),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_SimpleType_InT8,
			},
			EnumTypeKey: ID_mojom_types_SimpleType__,
			IntValue:    int32(3),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_SimpleType_InT16,
			},
			EnumTypeKey: ID_mojom_types_SimpleType__,
			IntValue:    int32(4),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_SimpleType_InT32,
			},
			EnumTypeKey: ID_mojom_types_SimpleType__,
			IntValue:    int32(5),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_SimpleType_InT64,
			},
			EnumTypeKey: ID_mojom_types_SimpleType__,
			IntValue:    int32(6),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_SimpleType_UinT8,
			},
			EnumTypeKey: ID_mojom_types_SimpleType__,
			IntValue:    int32(7),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_SimpleType_UinT16,
			},
			EnumTypeKey: ID_mojom_types_SimpleType__,
			IntValue:    int32(8),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_SimpleType_UinT32,
			},
			EnumTypeKey: ID_mojom_types_SimpleType__,
			IntValue:    int32(9),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_SimpleType_UinT64,
			},
			EnumTypeKey: ID_mojom_types_SimpleType__,
			IntValue:    int32(10),
		}},
	}
}

type BuiltinConstantValue int32

const (
	BuiltinConstantValue_DoubleInfinity         = 0
	BuiltinConstantValue_DoubleNegativeInfinity = BuiltinConstantValue_DoubleInfinity + 1
	BuiltinConstantValue_DoubleNan              = BuiltinConstantValue_DoubleNegativeInfinity + 1
	BuiltinConstantValue_FloatInfinity          = BuiltinConstantValue_DoubleNan + 1
	BuiltinConstantValue_FloatNegativeInfinity  = BuiltinConstantValue_FloatInfinity + 1
	BuiltinConstantValue_FloatNan               = BuiltinConstantValue_FloatNegativeInfinity + 1
)

// String names and labels used by the MojomEnum types.
var (
	enumName_BuiltinConstantValue                             = "BuiltinConstantValue"
	enumFieldName_BuiltinConstantValue_DoubleInfinity         = "DoubleInfinity"
	enumFieldName_BuiltinConstantValue_DoubleNegativeInfinity = "DoubleNegativeInfinity"
	enumFieldName_BuiltinConstantValue_DoubleNan              = "DoubleNan"
	enumFieldName_BuiltinConstantValue_FloatInfinity          = "FloatInfinity"
	enumFieldName_BuiltinConstantValue_FloatNegativeInfinity  = "FloatNegativeInfinity"
	enumFieldName_BuiltinConstantValue_FloatNan               = "FloatNan"
)

func mojom_types_BuiltinConstantValue__() MojomEnum {
	return MojomEnum{
		DeclData: &DeclarationData{
			ShortName: &enumName_BuiltinConstantValue,
		},
		Values: []EnumValue{EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_BuiltinConstantValue_DoubleInfinity,
			},
			EnumTypeKey: ID_mojom_types_BuiltinConstantValue__,
			IntValue:    int32(0),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_BuiltinConstantValue_DoubleNegativeInfinity,
			},
			EnumTypeKey: ID_mojom_types_BuiltinConstantValue__,
			IntValue:    int32(1),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_BuiltinConstantValue_DoubleNan,
			},
			EnumTypeKey: ID_mojom_types_BuiltinConstantValue__,
			IntValue:    int32(2),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_BuiltinConstantValue_FloatInfinity,
			},
			EnumTypeKey: ID_mojom_types_BuiltinConstantValue__,
			IntValue:    int32(3),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_BuiltinConstantValue_FloatNegativeInfinity,
			},
			EnumTypeKey: ID_mojom_types_BuiltinConstantValue__,
			IntValue:    int32(4),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_BuiltinConstantValue_FloatNan,
			},
			EnumTypeKey: ID_mojom_types_BuiltinConstantValue__,
			IntValue:    int32(5),
		}},
	}
}

type HandleType_Kind int32

const (
	HandleType_Kind_Unspecified      = 0
	HandleType_Kind_MessagePipe      = HandleType_Kind_Unspecified + 1
	HandleType_Kind_DataPipeConsumer = HandleType_Kind_MessagePipe + 1
	HandleType_Kind_DataPipeProducer = HandleType_Kind_DataPipeConsumer + 1
	HandleType_Kind_SharedBuffer     = HandleType_Kind_DataPipeProducer + 1
)

// String names and labels used by the MojomEnum types.
var (
	enumName_HandleType_Kind                       = "HandleType_Kind"
	enumFieldName_HandleType_Kind_Unspecified      = "Unspecified"
	enumFieldName_HandleType_Kind_MessagePipe      = "MessagePipe"
	enumFieldName_HandleType_Kind_DataPipeConsumer = "DataPipeConsumer"
	enumFieldName_HandleType_Kind_DataPipeProducer = "DataPipeProducer"
	enumFieldName_HandleType_Kind_SharedBuffer     = "SharedBuffer"
)

func mojom_types_Kind__() MojomEnum {
	return MojomEnum{
		DeclData: &DeclarationData{
			ShortName: &enumName_HandleType_Kind,
		},
		Values: []EnumValue{EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_HandleType_Kind_Unspecified,
			},
			EnumTypeKey: ID_mojom_types_Kind__,
			IntValue:    int32(0),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_HandleType_Kind_MessagePipe,
			},
			EnumTypeKey: ID_mojom_types_Kind__,
			IntValue:    int32(1),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_HandleType_Kind_DataPipeConsumer,
			},
			EnumTypeKey: ID_mojom_types_Kind__,
			IntValue:    int32(2),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_HandleType_Kind_DataPipeProducer,
			},
			EnumTypeKey: ID_mojom_types_Kind__,
			IntValue:    int32(3),
		}, EnumValue{
			DeclData: &DeclarationData{
				ShortName: &enumFieldName_HandleType_Kind_SharedBuffer,
			},
			EnumTypeKey: ID_mojom_types_Kind__,
			IntValue:    int32(4),
		}},
	}
}

type StringType struct {
	Nullable bool
}

func (s *StringType) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteBool(s.Nullable); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var stringType_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *StringType) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(stringType_Versions), func(i int) bool {
		return stringType_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(stringType_Versions) {
		if stringType_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := stringType_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.Nullable = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_StringType               = "StringType"
	structFieldName_StringType_Nullable = "Nullable"
)

func mojom_types_StringType__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_StringType,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_StringType_Nullable,
			},
			Type: &TypeSimpleType{SimpleType_Bool},
		}},
	}
}

type HandleType struct {
	Nullable bool
	Kind     HandleType_Kind
}

func (s *HandleType) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteBool(s.Nullable); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.Kind)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var handleType_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *HandleType) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(handleType_Versions), func(i int) bool {
		return handleType_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(handleType_Versions) {
		if handleType_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := handleType_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.Nullable = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Kind = HandleType_Kind(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_HandleType               = "HandleType"
	structFieldName_HandleType_Nullable = "Nullable"
	structFieldName_HandleType_Kind     = "Kind"
)

func mojom_types_HandleType__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_HandleType,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_HandleType_Nullable,
			},
			Type: &TypeSimpleType{SimpleType_Bool},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_HandleType_Kind,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_Kind__,
					TypeKey: &ID_mojom_types_Kind__},
			},
		}},
	}
}

type ArrayType struct {
	Nullable    bool
	FixedLength int32
	ElementType Type
}

func (s *ArrayType) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if err := encoder.WriteBool(s.Nullable); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.FixedLength); err != nil {
		return err
	}
	if s.ElementType == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.ElementType.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var arrayType_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *ArrayType) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(arrayType_Versions), func(i int) bool {
		return arrayType_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(arrayType_Versions) {
		if arrayType_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := arrayType_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.Nullable = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.FixedLength = value0
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.ElementType, err = DecodeType(decoder)
		if err != nil {
			return err
		}
		if s.ElementType == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_ArrayType                  = "ArrayType"
	structFieldName_ArrayType_Nullable    = "Nullable"
	structFieldName_ArrayType_FixedLength = "FixedLength"
	structFieldName_ArrayType_ElementType = "ElementType"
)

func mojom_types_ArrayType__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_ArrayType,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_ArrayType_Nullable,
			},
			Type: &TypeSimpleType{SimpleType_Bool},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_ArrayType_FixedLength,
			},
			Type: &TypeSimpleType{SimpleType_InT32},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_ArrayType_ElementType,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_Type__,
					TypeKey: &ID_mojom_types_Type__},
			},
		}},
	}
}

type MapType struct {
	Nullable  bool
	KeyType   Type
	ValueType Type
}

func (s *MapType) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(40, 0)
	if err := encoder.WriteBool(s.Nullable); err != nil {
		return err
	}
	if s.KeyType == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.KeyType.Encode(encoder); err != nil {
		return err
	}
	if s.ValueType == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.ValueType.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var mapType_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{48, 0},
}

func (s *MapType) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(mapType_Versions), func(i int) bool {
		return mapType_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(mapType_Versions) {
		if mapType_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := mapType_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.Nullable = value0
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.KeyType, err = DecodeType(decoder)
		if err != nil {
			return err
		}
		if s.KeyType == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.ValueType, err = DecodeType(decoder)
		if err != nil {
			return err
		}
		if s.ValueType == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_MapType                = "MapType"
	structFieldName_MapType_Nullable  = "Nullable"
	structFieldName_MapType_KeyType   = "KeyType"
	structFieldName_MapType_ValueType = "ValueType"
)

func mojom_types_MapType__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_MapType,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MapType_Nullable,
			},
			Type: &TypeSimpleType{SimpleType_Bool},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MapType_KeyType,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_Type__,
					TypeKey: &ID_mojom_types_Type__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MapType_ValueType,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_Type__,
					TypeKey: &ID_mojom_types_Type__},
			},
		}},
	}
}

type TypeReference struct {
	Nullable           bool
	IsInterfaceRequest bool
	Identifier         *string
	TypeKey            *string
}

func (s *TypeReference) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if err := encoder.WriteBool(s.Nullable); err != nil {
		return err
	}
	if err := encoder.WriteBool(s.IsInterfaceRequest); err != nil {
		return err
	}
	if s.Identifier == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.Identifier)); err != nil {
			return err
		}
	}
	if s.TypeKey == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.TypeKey)); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var typeReference_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *TypeReference) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(typeReference_Versions), func(i int) bool {
		return typeReference_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(typeReference_Versions) {
		if typeReference_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := typeReference_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.Nullable = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.IsInterfaceRequest = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Identifier = nil
		} else {
			s.Identifier = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.Identifier) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.TypeKey = nil
		} else {
			s.TypeKey = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.TypeKey) = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_TypeReference                         = "TypeReference"
	structFieldName_TypeReference_Nullable           = "Nullable"
	structFieldName_TypeReference_IsInterfaceRequest = "IsInterfaceRequest"
	structFieldName_TypeReference_Identifier         = "Identifier"
	structFieldName_TypeReference_TypeKey            = "TypeKey"
)

func mojom_types_TypeReference__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_TypeReference,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_TypeReference_Nullable,
			},
			Type: &TypeSimpleType{SimpleType_Bool},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_TypeReference_IsInterfaceRequest,
			},
			Type: &TypeSimpleType{SimpleType_Bool},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_TypeReference_Identifier,
			},
			Type: &TypeStringType{StringType{true}},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_TypeReference_TypeKey,
			},
			Type: &TypeStringType{StringType{true}},
		}},
	}
}

type StructField struct {
	DeclData     *DeclarationData
	Type         Type
	DefaultValue DefaultFieldValue
	Offset       int32
}

func (s *StructField) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(48, 0)
	if s.DeclData == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.DeclData).Encode(encoder); err != nil {
			return err
		}
	}
	if s.Type == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.Type.Encode(encoder); err != nil {
		return err
	}
	if s.DefaultValue == nil {
		encoder.WriteNullUnion()
	} else {
		if err := s.DefaultValue.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.WriteInt32(s.Offset); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structField_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{56, 0},
}

func (s *StructField) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structField_Versions), func(i int) bool {
		return structField_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structField_Versions) {
		if structField_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structField_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.DeclData = nil
		} else {
			s.DeclData = new(DeclarationData)
			if err := (*s.DeclData).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.Type, err = DecodeType(decoder)
		if err != nil {
			return err
		}
		if s.Type == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.DefaultValue, err = DecodeDefaultFieldValue(decoder)
		if err != nil {
			return err
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Offset = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_StructField                   = "StructField"
	structFieldName_StructField_DeclData     = "DeclData"
	structFieldName_StructField_Type         = "Type"
	structFieldName_StructField_DefaultValue = "DefaultValue"
	structFieldName_StructField_Offset       = "Offset"
)

func mojom_types_StructField__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_StructField,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_StructField_DeclData,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_DeclarationData__,
					TypeKey: &ID_mojom_types_DeclarationData__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_StructField_Type,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_Type__,
					TypeKey: &ID_mojom_types_Type__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_StructField_DefaultValue,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_DefaultFieldValue__,
					TypeKey: &ID_mojom_types_DefaultFieldValue__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_StructField_Offset,
			},
			Type: &TypeSimpleType{SimpleType_InT32},
		}},
	}
}

type DefaultKeyword struct {
}

func (s *DefaultKeyword) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var defaultKeyword_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *DefaultKeyword) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(defaultKeyword_Versions), func(i int) bool {
		return defaultKeyword_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(defaultKeyword_Versions) {
		if defaultKeyword_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := defaultKeyword_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_DefaultKeyword = "DefaultKeyword"
)

func mojom_types_DefaultKeyword__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_DefaultKeyword,
		}, Fields: []StructField{},
	}
}

type StructVersion struct {
	VersionNumber uint32
	NumFields     uint32
	NumBytes      uint32
}

func (s *StructVersion) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteUint32(s.VersionNumber); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.NumFields); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.NumBytes); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structVersion_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *StructVersion) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structVersion_Versions), func(i int) bool {
		return structVersion_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structVersion_Versions) {
		if structVersion_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structVersion_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.VersionNumber = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.NumFields = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.NumBytes = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_StructVersion                    = "StructVersion"
	structFieldName_StructVersion_VersionNumber = "VersionNumber"
	structFieldName_StructVersion_NumFields     = "NumFields"
	structFieldName_StructVersion_NumBytes      = "NumBytes"
)

func mojom_types_StructVersion__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_StructVersion,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_StructVersion_VersionNumber,
			},
			Type: &TypeSimpleType{SimpleType_UinT32},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_StructVersion_NumFields,
			},
			Type: &TypeSimpleType{SimpleType_UinT32},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_StructVersion_NumBytes,
			},
			Type: &TypeSimpleType{SimpleType_UinT32},
		}},
	}
}

type MojomStruct struct {
	DeclData    *DeclarationData
	Fields      []StructField
	VersionInfo *[]StructVersion
}

func (s *MojomStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if s.DeclData == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.DeclData).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.Fields)), 64)
	for _, elem0 := range s.Fields {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.VersionInfo == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.VersionInfo))), 64)
		for _, elem0 := range *s.VersionInfo {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem0.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var mojomStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *MojomStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(mojomStruct_Versions), func(i int) bool {
		return mojomStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(mojomStruct_Versions) {
		if mojomStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := mojomStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.DeclData = nil
		} else {
			s.DeclData = new(DeclarationData)
			if err := (*s.DeclData).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.Fields = make([]StructField, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := s.Fields[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.VersionInfo = nil
		} else {
			s.VersionInfo = new([]StructVersion)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.VersionInfo) = make([]StructVersion, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := (*s.VersionInfo)[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_MojomStruct                  = "MojomStruct"
	structFieldName_MojomStruct_DeclData    = "DeclData"
	structFieldName_MojomStruct_Fields      = "Fields"
	structFieldName_MojomStruct_VersionInfo = "VersionInfo"
)

func mojom_types_MojomStruct__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_MojomStruct,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomStruct_DeclData,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_DeclarationData__,
					TypeKey: &ID_mojom_types_DeclarationData__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomStruct_Fields,
			},
			Type: &TypeArrayType{
				Value: ArrayType{ElementType: &TypeTypeReference{
					Value: TypeReference{Identifier: &ID_mojom_types_StructField__,
						TypeKey: &ID_mojom_types_StructField__},
				},
				},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomStruct_VersionInfo,
			},
			Type: &TypeArrayType{
				Value: ArrayType{Nullable: true, ElementType: &TypeTypeReference{
					Value: TypeReference{Identifier: &ID_mojom_types_StructVersion__,
						TypeKey: &ID_mojom_types_StructVersion__},
				},
				},
			},
		}},
	}
}

type UnionField struct {
	DeclData *DeclarationData
	Type     Type
	Tag      uint32
}

func (s *UnionField) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if s.DeclData == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.DeclData).Encode(encoder); err != nil {
			return err
		}
	}
	if s.Type == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.Type.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.Tag); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var unionField_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *UnionField) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(unionField_Versions), func(i int) bool {
		return unionField_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(unionField_Versions) {
		if unionField_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := unionField_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.DeclData = nil
		} else {
			s.DeclData = new(DeclarationData)
			if err := (*s.DeclData).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.Type, err = DecodeType(decoder)
		if err != nil {
			return err
		}
		if s.Type == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.Tag = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_UnionField               = "UnionField"
	structFieldName_UnionField_DeclData = "DeclData"
	structFieldName_UnionField_Type     = "Type"
	structFieldName_UnionField_Tag      = "Tag"
)

func mojom_types_UnionField__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_UnionField,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_UnionField_DeclData,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_DeclarationData__,
					TypeKey: &ID_mojom_types_DeclarationData__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_UnionField_Type,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_Type__,
					TypeKey: &ID_mojom_types_Type__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_UnionField_Tag,
			},
			Type: &TypeSimpleType{SimpleType_UinT32},
		}},
	}
}

type MojomUnion struct {
	DeclData *DeclarationData
	Fields   []UnionField
}

func (s *MojomUnion) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.DeclData == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.DeclData).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.Fields)), 64)
	for _, elem0 := range s.Fields {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var mojomUnion_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *MojomUnion) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(mojomUnion_Versions), func(i int) bool {
		return mojomUnion_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(mojomUnion_Versions) {
		if mojomUnion_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := mojomUnion_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.DeclData = nil
		} else {
			s.DeclData = new(DeclarationData)
			if err := (*s.DeclData).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.Fields = make([]UnionField, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := s.Fields[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_MojomUnion               = "MojomUnion"
	structFieldName_MojomUnion_DeclData = "DeclData"
	structFieldName_MojomUnion_Fields   = "Fields"
)

func mojom_types_MojomUnion__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_MojomUnion,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomUnion_DeclData,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_DeclarationData__,
					TypeKey: &ID_mojom_types_DeclarationData__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomUnion_Fields,
			},
			Type: &TypeArrayType{
				Value: ArrayType{ElementType: &TypeTypeReference{
					Value: TypeReference{Identifier: &ID_mojom_types_UnionField__,
						TypeKey: &ID_mojom_types_UnionField__},
				},
				},
			},
		}},
	}
}

type EnumValue struct {
	DeclData         *DeclarationData
	EnumTypeKey      string
	InitializerValue Value
	IntValue         int32
}

func (s *EnumValue) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(40, 0)
	if s.DeclData == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.DeclData).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.EnumTypeKey); err != nil {
		return err
	}
	if s.InitializerValue == nil {
		encoder.WriteNullUnion()
	} else {
		if err := s.InitializerValue.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.WriteInt32(s.IntValue); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var enumValue_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{48, 0},
}

func (s *EnumValue) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(enumValue_Versions), func(i int) bool {
		return enumValue_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(enumValue_Versions) {
		if enumValue_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := enumValue_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.DeclData = nil
		} else {
			s.DeclData = new(DeclarationData)
			if err := (*s.DeclData).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.EnumTypeKey = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.InitializerValue, err = DecodeValue(decoder)
		if err != nil {
			return err
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.IntValue = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_EnumValue                       = "EnumValue"
	structFieldName_EnumValue_DeclData         = "DeclData"
	structFieldName_EnumValue_EnumTypeKey      = "EnumTypeKey"
	structFieldName_EnumValue_InitializerValue = "InitializerValue"
	structFieldName_EnumValue_IntValue         = "IntValue"
)

func mojom_types_EnumValue__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_EnumValue,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_EnumValue_DeclData,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_DeclarationData__,
					TypeKey: &ID_mojom_types_DeclarationData__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_EnumValue_EnumTypeKey,
			},
			Type: &TypeStringType{StringType{false}},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_EnumValue_InitializerValue,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_Value__,
					TypeKey: &ID_mojom_types_Value__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_EnumValue_IntValue,
			},
			Type: &TypeSimpleType{SimpleType_InT32},
		}},
	}
}

type MojomEnum struct {
	DeclData *DeclarationData
	Values   []EnumValue
}

func (s *MojomEnum) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.DeclData == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.DeclData).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.Values)), 64)
	for _, elem0 := range s.Values {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var mojomEnum_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *MojomEnum) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(mojomEnum_Versions), func(i int) bool {
		return mojomEnum_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(mojomEnum_Versions) {
		if mojomEnum_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := mojomEnum_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.DeclData = nil
		} else {
			s.DeclData = new(DeclarationData)
			if err := (*s.DeclData).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.Values = make([]EnumValue, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := s.Values[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_MojomEnum               = "MojomEnum"
	structFieldName_MojomEnum_DeclData = "DeclData"
	structFieldName_MojomEnum_Values   = "Values"
)

func mojom_types_MojomEnum__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_MojomEnum,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomEnum_DeclData,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_DeclarationData__,
					TypeKey: &ID_mojom_types_DeclarationData__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomEnum_Values,
			},
			Type: &TypeArrayType{
				Value: ArrayType{ElementType: &TypeTypeReference{
					Value: TypeReference{Identifier: &ID_mojom_types_EnumValue__,
						TypeKey: &ID_mojom_types_EnumValue__},
				},
				},
			},
		}},
	}
}

type MojomMethod struct {
	DeclData       *DeclarationData
	Parameters     MojomStruct
	ResponseParams *MojomStruct
	Ordinal        uint32
}

func (s *MojomMethod) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if s.DeclData == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.DeclData).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.Parameters.Encode(encoder); err != nil {
		return err
	}
	if s.ResponseParams == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.ResponseParams).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.WriteUint32(s.Ordinal); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var mojomMethod_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *MojomMethod) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(mojomMethod_Versions), func(i int) bool {
		return mojomMethod_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(mojomMethod_Versions) {
		if mojomMethod_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := mojomMethod_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.DeclData = nil
		} else {
			s.DeclData = new(DeclarationData)
			if err := (*s.DeclData).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.Parameters.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.ResponseParams = nil
		} else {
			s.ResponseParams = new(MojomStruct)
			if err := (*s.ResponseParams).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.Ordinal = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_MojomMethod                     = "MojomMethod"
	structFieldName_MojomMethod_DeclData       = "DeclData"
	structFieldName_MojomMethod_Parameters     = "Parameters"
	structFieldName_MojomMethod_ResponseParams = "ResponseParams"
	structFieldName_MojomMethod_Ordinal        = "Ordinal"
)

func mojom_types_MojomMethod__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_MojomMethod,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomMethod_DeclData,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_DeclarationData__,
					TypeKey: &ID_mojom_types_DeclarationData__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomMethod_Parameters,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_MojomStruct__,
					TypeKey: &ID_mojom_types_MojomStruct__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomMethod_ResponseParams,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_MojomStruct__,
					TypeKey: &ID_mojom_types_MojomStruct__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomMethod_Ordinal,
			},
			Type: &TypeSimpleType{SimpleType_UinT32},
		}},
	}
}

type MojomInterface struct {
	DeclData      *DeclarationData
	InterfaceName string
	Methods       map[uint32]MojomMethod
}

func (s *MojomInterface) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if s.DeclData == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.DeclData).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.InterfaceName); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []uint32
		var values0 []MojomMethod
		for key0, value0 := range s.Methods {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 32)
		for _, elem1 := range keys0 {
			if err := encoder.WriteUint32(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem1.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var mojomInterface_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *MojomInterface) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(mojomInterface_Versions), func(i int) bool {
		return mojomInterface_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(mojomInterface_Versions) {
		if mojomInterface_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := mojomInterface_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.DeclData = nil
		} else {
			s.DeclData = new(DeclarationData)
			if err := (*s.DeclData).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.InterfaceName = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []uint32
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(32)
					if err != nil {
						return err
					}
					keys0 = make([]uint32, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadUint32()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []MojomMethod
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([]MojomMethod, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							if err := values0[i1].Decode(decoder); err != nil {
								return err
							}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[uint32]MojomMethod)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.Methods = map0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_MojomInterface                    = "MojomInterface"
	structFieldName_MojomInterface_DeclData      = "DeclData"
	structFieldName_MojomInterface_InterfaceName = "InterfaceName"
	structFieldName_MojomInterface_Methods       = "Methods"
)

func mojom_types_MojomInterface__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_MojomInterface,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomInterface_DeclData,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_DeclarationData__,
					TypeKey: &ID_mojom_types_DeclarationData__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomInterface_InterfaceName,
			},
			Type: &TypeStringType{StringType{false}},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_MojomInterface_Methods,
			},
			Type: &TypeMapType{
				Value: MapType{KeyType: &TypeSimpleType{SimpleType_UinT32},
					ValueType: &TypeTypeReference{
						Value: TypeReference{Identifier: &ID_mojom_types_MojomMethod__,
							TypeKey: &ID_mojom_types_MojomMethod__},
					},
				},
			},
		}},
	}
}

type UserValueReference struct {
	Identifier            string
	ValueKey              *string
	ResolvedConcreteValue Value
}

func (s *UserValueReference) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.Identifier); err != nil {
		return err
	}
	if s.ValueKey == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.ValueKey)); err != nil {
			return err
		}
	}
	if s.ResolvedConcreteValue == nil {
		encoder.WriteNullUnion()
	} else {
		if err := s.ResolvedConcreteValue.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var userValueReference_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *UserValueReference) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(userValueReference_Versions), func(i int) bool {
		return userValueReference_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(userValueReference_Versions) {
		if userValueReference_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := userValueReference_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.Identifier = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.ValueKey = nil
		} else {
			s.ValueKey = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.ValueKey) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.ResolvedConcreteValue, err = DecodeValue(decoder)
		if err != nil {
			return err
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_UserValueReference                            = "UserValueReference"
	structFieldName_UserValueReference_Identifier            = "Identifier"
	structFieldName_UserValueReference_ValueKey              = "ValueKey"
	structFieldName_UserValueReference_ResolvedConcreteValue = "ResolvedConcreteValue"
)

func mojom_types_UserValueReference__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_UserValueReference,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_UserValueReference_Identifier,
			},
			Type: &TypeStringType{StringType{false}},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_UserValueReference_ValueKey,
			},
			Type: &TypeStringType{StringType{true}},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_UserValueReference_ResolvedConcreteValue,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_Value__,
					TypeKey: &ID_mojom_types_Value__},
			},
		}},
	}
}

type DeclaredConstant struct {
	DeclData DeclarationData
	Type     Type
	Value    Value
}

func (s *DeclaredConstant) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(40, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.DeclData.Encode(encoder); err != nil {
		return err
	}
	if s.Type == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.Type.Encode(encoder); err != nil {
		return err
	}
	if s.Value == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.Value.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var declaredConstant_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{48, 0},
}

func (s *DeclaredConstant) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(declaredConstant_Versions), func(i int) bool {
		return declaredConstant_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(declaredConstant_Versions) {
		if declaredConstant_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := declaredConstant_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.DeclData.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.Type, err = DecodeType(decoder)
		if err != nil {
			return err
		}
		if s.Type == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.Value, err = DecodeValue(decoder)
		if err != nil {
			return err
		}
		if s.Value == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_DeclaredConstant               = "DeclaredConstant"
	structFieldName_DeclaredConstant_DeclData = "DeclData"
	structFieldName_DeclaredConstant_Type     = "Type"
	structFieldName_DeclaredConstant_Value    = "Value"
)

func mojom_types_DeclaredConstant__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_DeclaredConstant,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_DeclaredConstant_DeclData,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_DeclarationData__,
					TypeKey: &ID_mojom_types_DeclarationData__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_DeclaredConstant_Type,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_Type__,
					TypeKey: &ID_mojom_types_Type__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_DeclaredConstant_Value,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_Value__,
					TypeKey: &ID_mojom_types_Value__},
			},
		}},
	}
}

type DeclarationData struct {
	Attributes            *[]Attribute
	MinVersion            int32
	ShortName             *string
	FullIdentifier        *string
	DeclaredOrdinal       int32
	DeclarationOrder      int32
	SourceFileInfo        *SourceFileInfo
	ContainedDeclarations *ContainedDeclarations
}

func (s *DeclarationData) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(56, 0)
	if s.Attributes == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.Attributes))), 64)
		for _, elem0 := range *s.Attributes {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem0.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.WriteInt32(s.MinVersion); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.DeclaredOrdinal); err != nil {
		return err
	}
	if s.ShortName == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.ShortName)); err != nil {
			return err
		}
	}
	if s.FullIdentifier == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.FullIdentifier)); err != nil {
			return err
		}
	}
	if err := encoder.WriteInt32(s.DeclarationOrder); err != nil {
		return err
	}
	if s.SourceFileInfo == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.SourceFileInfo).Encode(encoder); err != nil {
			return err
		}
	}
	if s.ContainedDeclarations == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.ContainedDeclarations).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var declarationData_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{64, 0},
}

func (s *DeclarationData) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(declarationData_Versions), func(i int) bool {
		return declarationData_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(declarationData_Versions) {
		if declarationData_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := declarationData_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Attributes = nil
		} else {
			s.Attributes = new([]Attribute)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.Attributes) = make([]Attribute, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := (*s.Attributes)[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.MinVersion = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.DeclaredOrdinal = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.ShortName = nil
		} else {
			s.ShortName = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.ShortName) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.FullIdentifier = nil
		} else {
			s.FullIdentifier = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.FullIdentifier) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.DeclarationOrder = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.SourceFileInfo = nil
		} else {
			s.SourceFileInfo = new(SourceFileInfo)
			if err := (*s.SourceFileInfo).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.ContainedDeclarations = nil
		} else {
			s.ContainedDeclarations = new(ContainedDeclarations)
			if err := (*s.ContainedDeclarations).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_DeclarationData                            = "DeclarationData"
	structFieldName_DeclarationData_Attributes            = "Attributes"
	structFieldName_DeclarationData_MinVersion            = "MinVersion"
	structFieldName_DeclarationData_ShortName             = "ShortName"
	structFieldName_DeclarationData_FullIdentifier        = "FullIdentifier"
	structFieldName_DeclarationData_DeclaredOrdinal       = "DeclaredOrdinal"
	structFieldName_DeclarationData_DeclarationOrder      = "DeclarationOrder"
	structFieldName_DeclarationData_SourceFileInfo        = "SourceFileInfo"
	structFieldName_DeclarationData_ContainedDeclarations = "ContainedDeclarations"
)

func mojom_types_DeclarationData__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_DeclarationData,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_DeclarationData_Attributes,
			},
			Type: &TypeArrayType{
				Value: ArrayType{Nullable: true, ElementType: &TypeTypeReference{
					Value: TypeReference{Identifier: &ID_mojom_types_Attribute__,
						TypeKey: &ID_mojom_types_Attribute__},
				},
				},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_DeclarationData_MinVersion,
			},
			Type: &TypeSimpleType{SimpleType_InT32},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_DeclarationData_ShortName,
			},
			Type: &TypeStringType{StringType{true}},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_DeclarationData_FullIdentifier,
			},
			Type: &TypeStringType{StringType{true}},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_DeclarationData_DeclaredOrdinal,
			},
			Type: &TypeSimpleType{SimpleType_InT32},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_DeclarationData_DeclarationOrder,
			},
			Type: &TypeSimpleType{SimpleType_InT32},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_DeclarationData_SourceFileInfo,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_SourceFileInfo__,
					TypeKey: &ID_mojom_types_SourceFileInfo__},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_DeclarationData_ContainedDeclarations,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Nullable: true, Identifier: &ID_mojom_types_ContainedDeclarations__,
					TypeKey: &ID_mojom_types_ContainedDeclarations__},
			},
		}},
	}
}

type SourceFileInfo struct {
	FileName     string
	LineNumber   uint32
	ColumnNumber uint32
}

func (s *SourceFileInfo) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.FileName); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.LineNumber); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.ColumnNumber); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var sourceFileInfo_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *SourceFileInfo) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(sourceFileInfo_Versions), func(i int) bool {
		return sourceFileInfo_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(sourceFileInfo_Versions) {
		if sourceFileInfo_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := sourceFileInfo_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.FileName = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.LineNumber = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.ColumnNumber = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_SourceFileInfo                   = "SourceFileInfo"
	structFieldName_SourceFileInfo_FileName     = "FileName"
	structFieldName_SourceFileInfo_LineNumber   = "LineNumber"
	structFieldName_SourceFileInfo_ColumnNumber = "ColumnNumber"
)

func mojom_types_SourceFileInfo__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_SourceFileInfo,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_SourceFileInfo_FileName,
			},
			Type: &TypeStringType{StringType{false}},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_SourceFileInfo_LineNumber,
			},
			Type: &TypeSimpleType{SimpleType_UinT32},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_SourceFileInfo_ColumnNumber,
			},
			Type: &TypeSimpleType{SimpleType_UinT32},
		}},
	}
}

type ContainedDeclarations struct {
	Enums     *[]string
	Constants *[]string
}

func (s *ContainedDeclarations) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.Enums == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.Enums))), 64)
		for _, elem0 := range *s.Enums {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if s.Constants == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.Constants))), 64)
		for _, elem0 := range *s.Constants {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var containedDeclarations_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *ContainedDeclarations) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(containedDeclarations_Versions), func(i int) bool {
		return containedDeclarations_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(containedDeclarations_Versions) {
		if containedDeclarations_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := containedDeclarations_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Enums = nil
		} else {
			s.Enums = new([]string)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.Enums) = make([]string, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					value1, err := decoder.ReadString()
					if err != nil {
						return err
					}
					(*s.Enums)[i0] = value1
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Constants = nil
		} else {
			s.Constants = new([]string)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.Constants) = make([]string, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					value1, err := decoder.ReadString()
					if err != nil {
						return err
					}
					(*s.Constants)[i0] = value1
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_ContainedDeclarations                = "ContainedDeclarations"
	structFieldName_ContainedDeclarations_Enums     = "Enums"
	structFieldName_ContainedDeclarations_Constants = "Constants"
)

func mojom_types_ContainedDeclarations__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_ContainedDeclarations,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_ContainedDeclarations_Enums,
			},
			Type: &TypeArrayType{
				Value: ArrayType{Nullable: true, ElementType: &TypeStringType{StringType{false}}},
			},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_ContainedDeclarations_Constants,
			},
			Type: &TypeArrayType{
				Value: ArrayType{Nullable: true, ElementType: &TypeStringType{StringType{false}}},
			},
		}},
	}
}

type Attribute struct {
	Key   string
	Value string
}

func (s *Attribute) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.Key); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.Value); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var attribute_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *Attribute) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(attribute_Versions), func(i int) bool {
		return attribute_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(attribute_Versions) {
		if attribute_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := attribute_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.Key = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.Value = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

// String names and labels used by the MojomStruct types.
var (
	structName_Attribute            = "Attribute"
	structFieldName_Attribute_Key   = "Key"
	structFieldName_Attribute_Value = "Value"
)

func mojom_types_Attribute__() MojomStruct {
	return MojomStruct{
		DeclData: &DeclarationData{
			ShortName: &structName_Attribute,
		}, Fields: []StructField{StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_Attribute_Key,
			},
			Type: &TypeStringType{StringType{false}},
		}, StructField{
			DeclData: &DeclarationData{
				ShortName: &structFieldName_Attribute_Value,
			},
			Type: &TypeStringType{StringType{false}},
		}},
	}
}

type Type interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__TypeReflect)
	Encode(encoder *bindings.Encoder) error
}

type __TypeReflect struct {
	SimpleType    SimpleType
	StringType    StringType
	ArrayType     ArrayType
	MapType       MapType
	HandleType    HandleType
	TypeReference TypeReference
}

func DecodeType(decoder *bindings.Decoder) (Type, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value TypeSimpleType
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value TypeStringType
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 2:
		var value TypeArrayType
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 3:
		var value TypeMapType
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 4:
		var value TypeHandleType
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 5:
		var value TypeTypeReference
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &TypeUnknown{tag: tag}, nil
}

type TypeUnknown struct{ tag uint32 }

func (u *TypeUnknown) Tag() uint32             { return u.tag }
func (u *TypeUnknown) Interface() interface{}  { return nil }
func (u *TypeUnknown) __Reflect(__TypeReflect) {}

func (u *TypeUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown Type. There is no sane way to do that!")
}

type TypeSimpleType struct{ Value SimpleType }

func (u *TypeSimpleType) Tag() uint32             { return 0 }
func (u *TypeSimpleType) Interface() interface{}  { return u.Value }
func (u *TypeSimpleType) __Reflect(__TypeReflect) {}

func (u *TypeSimpleType) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt32(int32(u.Value)); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *TypeSimpleType) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt32()
	if err != nil {
		return err
	}
	u.Value = SimpleType(value0)

	return nil
}

type TypeStringType struct{ Value StringType }

func (u *TypeStringType) Tag() uint32             { return 1 }
func (u *TypeStringType) Interface() interface{}  { return u.Value }
func (u *TypeStringType) __Reflect(__TypeReflect) {}

func (u *TypeStringType) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *TypeStringType) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}

	return nil
}

type TypeArrayType struct{ Value ArrayType }

func (u *TypeArrayType) Tag() uint32             { return 2 }
func (u *TypeArrayType) Interface() interface{}  { return u.Value }
func (u *TypeArrayType) __Reflect(__TypeReflect) {}

func (u *TypeArrayType) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *TypeArrayType) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}

	return nil
}

type TypeMapType struct{ Value MapType }

func (u *TypeMapType) Tag() uint32             { return 3 }
func (u *TypeMapType) Interface() interface{}  { return u.Value }
func (u *TypeMapType) __Reflect(__TypeReflect) {}

func (u *TypeMapType) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *TypeMapType) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}

	return nil
}

type TypeHandleType struct{ Value HandleType }

func (u *TypeHandleType) Tag() uint32             { return 4 }
func (u *TypeHandleType) Interface() interface{}  { return u.Value }
func (u *TypeHandleType) __Reflect(__TypeReflect) {}

func (u *TypeHandleType) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *TypeHandleType) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}

	return nil
}

type TypeTypeReference struct{ Value TypeReference }

func (u *TypeTypeReference) Tag() uint32             { return 5 }
func (u *TypeTypeReference) Interface() interface{}  { return u.Value }
func (u *TypeTypeReference) __Reflect(__TypeReflect) {}

func (u *TypeTypeReference) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *TypeTypeReference) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}

	return nil
}

// String names and labels used by the MojomUnion types.
var (
	unionName_Type                    = "Type"
	unionFieldName_Type_SimpleType    = "SimpleType"
	unionFieldName_Type_StringType    = "StringType"
	unionFieldName_Type_ArrayType     = "ArrayType"
	unionFieldName_Type_MapType       = "MapType"
	unionFieldName_Type_HandleType    = "HandleType"
	unionFieldName_Type_TypeReference = "TypeReference"
)

func mojom_types_Type__() MojomUnion {
	return MojomUnion{
		DeclData: &DeclarationData{
			ShortName: &unionName_Type,
		}, Fields: []UnionField{UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_Type_SimpleType,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_SimpleType__,
					TypeKey: &ID_mojom_types_SimpleType__},
			},
			Tag: 0,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_Type_StringType,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_StringType__,
					TypeKey: &ID_mojom_types_StringType__},
			},
			Tag: 1,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_Type_ArrayType,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_ArrayType__,
					TypeKey: &ID_mojom_types_ArrayType__},
			},
			Tag: 2,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_Type_MapType,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_MapType__,
					TypeKey: &ID_mojom_types_MapType__},
			},
			Tag: 3,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_Type_HandleType,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_HandleType__,
					TypeKey: &ID_mojom_types_HandleType__},
			},
			Tag: 4,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_Type_TypeReference,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_TypeReference__,
					TypeKey: &ID_mojom_types_TypeReference__},
			},
			Tag: 5,
		}},
	}
}

type UserDefinedType interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__UserDefinedTypeReflect)
	Encode(encoder *bindings.Encoder) error
}

type __UserDefinedTypeReflect struct {
	EnumType      MojomEnum
	StructType    MojomStruct
	UnionType     MojomUnion
	InterfaceType MojomInterface
}

func DecodeUserDefinedType(decoder *bindings.Decoder) (UserDefinedType, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value UserDefinedTypeEnumType
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value UserDefinedTypeStructType
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 2:
		var value UserDefinedTypeUnionType
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 3:
		var value UserDefinedTypeInterfaceType
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &UserDefinedTypeUnknown{tag: tag}, nil
}

type UserDefinedTypeUnknown struct{ tag uint32 }

func (u *UserDefinedTypeUnknown) Tag() uint32                        { return u.tag }
func (u *UserDefinedTypeUnknown) Interface() interface{}             { return nil }
func (u *UserDefinedTypeUnknown) __Reflect(__UserDefinedTypeReflect) {}

func (u *UserDefinedTypeUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown UserDefinedType. There is no sane way to do that!")
}

type UserDefinedTypeEnumType struct{ Value MojomEnum }

func (u *UserDefinedTypeEnumType) Tag() uint32                        { return 0 }
func (u *UserDefinedTypeEnumType) Interface() interface{}             { return u.Value }
func (u *UserDefinedTypeEnumType) __Reflect(__UserDefinedTypeReflect) {}

func (u *UserDefinedTypeEnumType) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UserDefinedTypeEnumType) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}

	return nil
}

type UserDefinedTypeStructType struct{ Value MojomStruct }

func (u *UserDefinedTypeStructType) Tag() uint32                        { return 1 }
func (u *UserDefinedTypeStructType) Interface() interface{}             { return u.Value }
func (u *UserDefinedTypeStructType) __Reflect(__UserDefinedTypeReflect) {}

func (u *UserDefinedTypeStructType) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UserDefinedTypeStructType) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}

	return nil
}

type UserDefinedTypeUnionType struct{ Value MojomUnion }

func (u *UserDefinedTypeUnionType) Tag() uint32                        { return 2 }
func (u *UserDefinedTypeUnionType) Interface() interface{}             { return u.Value }
func (u *UserDefinedTypeUnionType) __Reflect(__UserDefinedTypeReflect) {}

func (u *UserDefinedTypeUnionType) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UserDefinedTypeUnionType) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}

	return nil
}

type UserDefinedTypeInterfaceType struct{ Value MojomInterface }

func (u *UserDefinedTypeInterfaceType) Tag() uint32                        { return 3 }
func (u *UserDefinedTypeInterfaceType) Interface() interface{}             { return u.Value }
func (u *UserDefinedTypeInterfaceType) __Reflect(__UserDefinedTypeReflect) {}

func (u *UserDefinedTypeInterfaceType) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UserDefinedTypeInterfaceType) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}

	return nil
}

// String names and labels used by the MojomUnion types.
var (
	unionName_UserDefinedType                    = "UserDefinedType"
	unionFieldName_UserDefinedType_EnumType      = "EnumType"
	unionFieldName_UserDefinedType_StructType    = "StructType"
	unionFieldName_UserDefinedType_UnionType     = "UnionType"
	unionFieldName_UserDefinedType_InterfaceType = "InterfaceType"
)

func mojom_types_UserDefinedType__() MojomUnion {
	return MojomUnion{
		DeclData: &DeclarationData{
			ShortName: &unionName_UserDefinedType,
		}, Fields: []UnionField{UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_UserDefinedType_EnumType,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_MojomEnum__,
					TypeKey: &ID_mojom_types_MojomEnum__},
			},
			Tag: 0,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_UserDefinedType_StructType,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_MojomStruct__,
					TypeKey: &ID_mojom_types_MojomStruct__},
			},
			Tag: 1,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_UserDefinedType_UnionType,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_MojomUnion__,
					TypeKey: &ID_mojom_types_MojomUnion__},
			},
			Tag: 2,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_UserDefinedType_InterfaceType,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_MojomInterface__,
					TypeKey: &ID_mojom_types_MojomInterface__},
			},
			Tag: 3,
		}},
	}
}

type DefaultFieldValue interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__DefaultFieldValueReflect)
	Encode(encoder *bindings.Encoder) error
}

type __DefaultFieldValueReflect struct {
	Value          Value
	DefaultKeyword DefaultKeyword
}

func DecodeDefaultFieldValue(decoder *bindings.Decoder) (DefaultFieldValue, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value DefaultFieldValueValue
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value DefaultFieldValueDefaultKeyword
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &DefaultFieldValueUnknown{tag: tag}, nil
}

type DefaultFieldValueUnknown struct{ tag uint32 }

func (u *DefaultFieldValueUnknown) Tag() uint32                          { return u.tag }
func (u *DefaultFieldValueUnknown) Interface() interface{}               { return nil }
func (u *DefaultFieldValueUnknown) __Reflect(__DefaultFieldValueReflect) {}

func (u *DefaultFieldValueUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown DefaultFieldValue. There is no sane way to do that!")
}

type DefaultFieldValueValue struct{ Value Value }

func (u *DefaultFieldValueValue) Tag() uint32                          { return 0 }
func (u *DefaultFieldValueValue) Interface() interface{}               { return u.Value }
func (u *DefaultFieldValueValue) __Reflect(__DefaultFieldValueReflect) {}

func (u *DefaultFieldValueValue) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}

	encoder.StartNestedUnion()
	if u.Value == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.Finish()
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *DefaultFieldValueValue) decodeInternal(decoder *bindings.Decoder) error {
	if pointer, err := decoder.ReadPointer(); err != nil || pointer == 0 {
		if err != nil {
			return err
		}
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null union pointer"}
	}

	if err := decoder.StartNestedUnion(); err != nil {
		return err
	}

	var err error
	u.Value, err = DecodeValue(decoder)
	if err != nil {
		return err
	}
	if u.Value == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}

	decoder.Finish()
	return nil
}

type DefaultFieldValueDefaultKeyword struct{ Value DefaultKeyword }

func (u *DefaultFieldValueDefaultKeyword) Tag() uint32                          { return 1 }
func (u *DefaultFieldValueDefaultKeyword) Interface() interface{}               { return u.Value }
func (u *DefaultFieldValueDefaultKeyword) __Reflect(__DefaultFieldValueReflect) {}

func (u *DefaultFieldValueDefaultKeyword) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *DefaultFieldValueDefaultKeyword) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}

	return nil
}

// String names and labels used by the MojomUnion types.
var (
	unionName_DefaultFieldValue                     = "DefaultFieldValue"
	unionFieldName_DefaultFieldValue_Value          = "Value"
	unionFieldName_DefaultFieldValue_DefaultKeyword = "DefaultKeyword"
)

func mojom_types_DefaultFieldValue__() MojomUnion {
	return MojomUnion{
		DeclData: &DeclarationData{
			ShortName: &unionName_DefaultFieldValue,
		}, Fields: []UnionField{UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_DefaultFieldValue_Value,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_Value__,
					TypeKey: &ID_mojom_types_Value__},
			},
			Tag: 0,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_DefaultFieldValue_DefaultKeyword,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_DefaultKeyword__,
					TypeKey: &ID_mojom_types_DefaultKeyword__},
			},
			Tag: 1,
		}},
	}
}

type Value interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__ValueReflect)
	Encode(encoder *bindings.Encoder) error
}

type __ValueReflect struct {
	LiteralValue       LiteralValue
	UserValueReference UserValueReference
	BuiltinValue       BuiltinConstantValue
}

func DecodeValue(decoder *bindings.Decoder) (Value, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value ValueLiteralValue
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value ValueUserValueReference
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 2:
		var value ValueBuiltinValue
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &ValueUnknown{tag: tag}, nil
}

type ValueUnknown struct{ tag uint32 }

func (u *ValueUnknown) Tag() uint32              { return u.tag }
func (u *ValueUnknown) Interface() interface{}   { return nil }
func (u *ValueUnknown) __Reflect(__ValueReflect) {}

func (u *ValueUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown Value. There is no sane way to do that!")
}

type ValueLiteralValue struct{ Value LiteralValue }

func (u *ValueLiteralValue) Tag() uint32              { return 0 }
func (u *ValueLiteralValue) Interface() interface{}   { return u.Value }
func (u *ValueLiteralValue) __Reflect(__ValueReflect) {}

func (u *ValueLiteralValue) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}

	encoder.StartNestedUnion()
	if u.Value == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.Finish()
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *ValueLiteralValue) decodeInternal(decoder *bindings.Decoder) error {
	if pointer, err := decoder.ReadPointer(); err != nil || pointer == 0 {
		if err != nil {
			return err
		}
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null union pointer"}
	}

	if err := decoder.StartNestedUnion(); err != nil {
		return err
	}

	var err error
	u.Value, err = DecodeLiteralValue(decoder)
	if err != nil {
		return err
	}
	if u.Value == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}

	decoder.Finish()
	return nil
}

type ValueUserValueReference struct{ Value UserValueReference }

func (u *ValueUserValueReference) Tag() uint32              { return 1 }
func (u *ValueUserValueReference) Interface() interface{}   { return u.Value }
func (u *ValueUserValueReference) __Reflect(__ValueReflect) {}

func (u *ValueUserValueReference) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *ValueUserValueReference) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}

	return nil
}

type ValueBuiltinValue struct{ Value BuiltinConstantValue }

func (u *ValueBuiltinValue) Tag() uint32              { return 2 }
func (u *ValueBuiltinValue) Interface() interface{}   { return u.Value }
func (u *ValueBuiltinValue) __Reflect(__ValueReflect) {}

func (u *ValueBuiltinValue) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt32(int32(u.Value)); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *ValueBuiltinValue) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt32()
	if err != nil {
		return err
	}
	u.Value = BuiltinConstantValue(value0)

	return nil
}

// String names and labels used by the MojomUnion types.
var (
	unionName_Value                         = "Value"
	unionFieldName_Value_LiteralValue       = "LiteralValue"
	unionFieldName_Value_UserValueReference = "UserValueReference"
	unionFieldName_Value_BuiltinValue       = "BuiltinValue"
)

func mojom_types_Value__() MojomUnion {
	return MojomUnion{
		DeclData: &DeclarationData{
			ShortName: &unionName_Value,
		}, Fields: []UnionField{UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_Value_LiteralValue,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_LiteralValue__,
					TypeKey: &ID_mojom_types_LiteralValue__},
			},
			Tag: 0,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_Value_UserValueReference,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_UserValueReference__,
					TypeKey: &ID_mojom_types_UserValueReference__},
			},
			Tag: 1,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_Value_BuiltinValue,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_BuiltinConstantValue__,
					TypeKey: &ID_mojom_types_BuiltinConstantValue__},
			},
			Tag: 2,
		}},
	}
}

type LiteralValue interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__LiteralValueReflect)
	Encode(encoder *bindings.Encoder) error
}

type __LiteralValueReflect struct {
	BoolValue   bool
	DoubleValue float64
	FloatValue  float32
	Int8Value   int8
	Int16Value  int16
	Int32Value  int32
	Int64Value  int64
	StringValue string
	Uint8Value  uint8
	Uint16Value uint16
	Uint32Value uint32
	Uint64Value uint64
}

func DecodeLiteralValue(decoder *bindings.Decoder) (LiteralValue, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value LiteralValueBoolValue
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value LiteralValueDoubleValue
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 2:
		var value LiteralValueFloatValue
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 3:
		var value LiteralValueInt8Value
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 4:
		var value LiteralValueInt16Value
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 5:
		var value LiteralValueInt32Value
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 6:
		var value LiteralValueInt64Value
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 7:
		var value LiteralValueStringValue
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 8:
		var value LiteralValueUint8Value
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 9:
		var value LiteralValueUint16Value
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 10:
		var value LiteralValueUint32Value
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 11:
		var value LiteralValueUint64Value
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &LiteralValueUnknown{tag: tag}, nil
}

type LiteralValueUnknown struct{ tag uint32 }

func (u *LiteralValueUnknown) Tag() uint32                     { return u.tag }
func (u *LiteralValueUnknown) Interface() interface{}          { return nil }
func (u *LiteralValueUnknown) __Reflect(__LiteralValueReflect) {}

func (u *LiteralValueUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown LiteralValue. There is no sane way to do that!")
}

type LiteralValueBoolValue struct{ Value bool }

func (u *LiteralValueBoolValue) Tag() uint32                     { return 0 }
func (u *LiteralValueBoolValue) Interface() interface{}          { return u.Value }
func (u *LiteralValueBoolValue) __Reflect(__LiteralValueReflect) {}

func (u *LiteralValueBoolValue) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteBool(u.Value); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *LiteralValueBoolValue) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadBool()
	if err != nil {
		return err
	}
	u.Value = value0

	return nil
}

type LiteralValueDoubleValue struct{ Value float64 }

func (u *LiteralValueDoubleValue) Tag() uint32                     { return 1 }
func (u *LiteralValueDoubleValue) Interface() interface{}          { return u.Value }
func (u *LiteralValueDoubleValue) __Reflect(__LiteralValueReflect) {}

func (u *LiteralValueDoubleValue) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteFloat64(u.Value); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *LiteralValueDoubleValue) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadFloat64()
	if err != nil {
		return err
	}
	u.Value = value0

	return nil
}

type LiteralValueFloatValue struct{ Value float32 }

func (u *LiteralValueFloatValue) Tag() uint32                     { return 2 }
func (u *LiteralValueFloatValue) Interface() interface{}          { return u.Value }
func (u *LiteralValueFloatValue) __Reflect(__LiteralValueReflect) {}

func (u *LiteralValueFloatValue) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteFloat32(u.Value); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *LiteralValueFloatValue) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadFloat32()
	if err != nil {
		return err
	}
	u.Value = value0

	return nil
}

type LiteralValueInt8Value struct{ Value int8 }

func (u *LiteralValueInt8Value) Tag() uint32                     { return 3 }
func (u *LiteralValueInt8Value) Interface() interface{}          { return u.Value }
func (u *LiteralValueInt8Value) __Reflect(__LiteralValueReflect) {}

func (u *LiteralValueInt8Value) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt8(u.Value); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *LiteralValueInt8Value) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt8()
	if err != nil {
		return err
	}
	u.Value = value0

	return nil
}

type LiteralValueInt16Value struct{ Value int16 }

func (u *LiteralValueInt16Value) Tag() uint32                     { return 4 }
func (u *LiteralValueInt16Value) Interface() interface{}          { return u.Value }
func (u *LiteralValueInt16Value) __Reflect(__LiteralValueReflect) {}

func (u *LiteralValueInt16Value) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt16(u.Value); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *LiteralValueInt16Value) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt16()
	if err != nil {
		return err
	}
	u.Value = value0

	return nil
}

type LiteralValueInt32Value struct{ Value int32 }

func (u *LiteralValueInt32Value) Tag() uint32                     { return 5 }
func (u *LiteralValueInt32Value) Interface() interface{}          { return u.Value }
func (u *LiteralValueInt32Value) __Reflect(__LiteralValueReflect) {}

func (u *LiteralValueInt32Value) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt32(u.Value); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *LiteralValueInt32Value) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt32()
	if err != nil {
		return err
	}
	u.Value = value0

	return nil
}

type LiteralValueInt64Value struct{ Value int64 }

func (u *LiteralValueInt64Value) Tag() uint32                     { return 6 }
func (u *LiteralValueInt64Value) Interface() interface{}          { return u.Value }
func (u *LiteralValueInt64Value) __Reflect(__LiteralValueReflect) {}

func (u *LiteralValueInt64Value) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt64(u.Value); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *LiteralValueInt64Value) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt64()
	if err != nil {
		return err
	}
	u.Value = value0

	return nil
}

type LiteralValueStringValue struct{ Value string }

func (u *LiteralValueStringValue) Tag() uint32                     { return 7 }
func (u *LiteralValueStringValue) Interface() interface{}          { return u.Value }
func (u *LiteralValueStringValue) __Reflect(__LiteralValueReflect) {}

func (u *LiteralValueStringValue) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(u.Value); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *LiteralValueStringValue) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		value0, err := decoder.ReadString()
		if err != nil {
			return err
		}
		u.Value = value0
	}

	return nil
}

type LiteralValueUint8Value struct{ Value uint8 }

func (u *LiteralValueUint8Value) Tag() uint32                     { return 8 }
func (u *LiteralValueUint8Value) Interface() interface{}          { return u.Value }
func (u *LiteralValueUint8Value) __Reflect(__LiteralValueReflect) {}

func (u *LiteralValueUint8Value) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint8(u.Value); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *LiteralValueUint8Value) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint8()
	if err != nil {
		return err
	}
	u.Value = value0

	return nil
}

type LiteralValueUint16Value struct{ Value uint16 }

func (u *LiteralValueUint16Value) Tag() uint32                     { return 9 }
func (u *LiteralValueUint16Value) Interface() interface{}          { return u.Value }
func (u *LiteralValueUint16Value) __Reflect(__LiteralValueReflect) {}

func (u *LiteralValueUint16Value) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint16(u.Value); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *LiteralValueUint16Value) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint16()
	if err != nil {
		return err
	}
	u.Value = value0

	return nil
}

type LiteralValueUint32Value struct{ Value uint32 }

func (u *LiteralValueUint32Value) Tag() uint32                     { return 10 }
func (u *LiteralValueUint32Value) Interface() interface{}          { return u.Value }
func (u *LiteralValueUint32Value) __Reflect(__LiteralValueReflect) {}

func (u *LiteralValueUint32Value) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint32(u.Value); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *LiteralValueUint32Value) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint32()
	if err != nil {
		return err
	}
	u.Value = value0

	return nil
}

type LiteralValueUint64Value struct{ Value uint64 }

func (u *LiteralValueUint64Value) Tag() uint32                     { return 11 }
func (u *LiteralValueUint64Value) Interface() interface{}          { return u.Value }
func (u *LiteralValueUint64Value) __Reflect(__LiteralValueReflect) {}

func (u *LiteralValueUint64Value) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint64(u.Value); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *LiteralValueUint64Value) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint64()
	if err != nil {
		return err
	}
	u.Value = value0

	return nil
}

// String names and labels used by the MojomUnion types.
var (
	unionName_LiteralValue                  = "LiteralValue"
	unionFieldName_LiteralValue_BoolValue   = "BoolValue"
	unionFieldName_LiteralValue_DoubleValue = "DoubleValue"
	unionFieldName_LiteralValue_FloatValue  = "FloatValue"
	unionFieldName_LiteralValue_Int8Value   = "Int8Value"
	unionFieldName_LiteralValue_Int16Value  = "Int16Value"
	unionFieldName_LiteralValue_Int32Value  = "Int32Value"
	unionFieldName_LiteralValue_Int64Value  = "Int64Value"
	unionFieldName_LiteralValue_StringValue = "StringValue"
	unionFieldName_LiteralValue_Uint8Value  = "Uint8Value"
	unionFieldName_LiteralValue_Uint16Value = "Uint16Value"
	unionFieldName_LiteralValue_Uint32Value = "Uint32Value"
	unionFieldName_LiteralValue_Uint64Value = "Uint64Value"
)

func mojom_types_LiteralValue__() MojomUnion {
	return MojomUnion{
		DeclData: &DeclarationData{
			ShortName: &unionName_LiteralValue,
		}, Fields: []UnionField{UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_LiteralValue_BoolValue,
			},
			Type: &TypeSimpleType{SimpleType_Bool},
			Tag:  0,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_LiteralValue_DoubleValue,
			},
			Type: &TypeSimpleType{SimpleType_Double},
			Tag:  1,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_LiteralValue_FloatValue,
			},
			Type: &TypeSimpleType{SimpleType_Float},
			Tag:  2,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_LiteralValue_Int8Value,
			},
			Type: &TypeSimpleType{SimpleType_InT8},
			Tag:  3,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_LiteralValue_Int16Value,
			},
			Type: &TypeSimpleType{SimpleType_InT16},
			Tag:  4,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_LiteralValue_Int32Value,
			},
			Type: &TypeSimpleType{SimpleType_InT32},
			Tag:  5,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_LiteralValue_Int64Value,
			},
			Type: &TypeSimpleType{SimpleType_InT64},
			Tag:  6,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_LiteralValue_StringValue,
			},
			Type: &TypeStringType{StringType{false}},
			Tag:  7,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_LiteralValue_Uint8Value,
			},
			Type: &TypeSimpleType{SimpleType_UinT8},
			Tag:  8,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_LiteralValue_Uint16Value,
			},
			Type: &TypeSimpleType{SimpleType_UinT16},
			Tag:  9,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_LiteralValue_Uint32Value,
			},
			Type: &TypeSimpleType{SimpleType_UinT32},
			Tag:  10,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_LiteralValue_Uint64Value,
			},
			Type: &TypeSimpleType{SimpleType_UinT64},
			Tag:  11,
		}},
	}
}

type UserDefinedValue interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__UserDefinedValueReflect)
	Encode(encoder *bindings.Encoder) error
}

type __UserDefinedValueReflect struct {
	EnumValue        EnumValue
	DeclaredConstant DeclaredConstant
}

func DecodeUserDefinedValue(decoder *bindings.Decoder) (UserDefinedValue, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value UserDefinedValueEnumValue
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value UserDefinedValueDeclaredConstant
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &UserDefinedValueUnknown{tag: tag}, nil
}

type UserDefinedValueUnknown struct{ tag uint32 }

func (u *UserDefinedValueUnknown) Tag() uint32                         { return u.tag }
func (u *UserDefinedValueUnknown) Interface() interface{}              { return nil }
func (u *UserDefinedValueUnknown) __Reflect(__UserDefinedValueReflect) {}

func (u *UserDefinedValueUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown UserDefinedValue. There is no sane way to do that!")
}

type UserDefinedValueEnumValue struct{ Value EnumValue }

func (u *UserDefinedValueEnumValue) Tag() uint32                         { return 0 }
func (u *UserDefinedValueEnumValue) Interface() interface{}              { return u.Value }
func (u *UserDefinedValueEnumValue) __Reflect(__UserDefinedValueReflect) {}

func (u *UserDefinedValueEnumValue) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UserDefinedValueEnumValue) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}

	return nil
}

type UserDefinedValueDeclaredConstant struct{ Value DeclaredConstant }

func (u *UserDefinedValueDeclaredConstant) Tag() uint32                         { return 1 }
func (u *UserDefinedValueDeclaredConstant) Interface() interface{}              { return u.Value }
func (u *UserDefinedValueDeclaredConstant) __Reflect(__UserDefinedValueReflect) {}

func (u *UserDefinedValueDeclaredConstant) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}

	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UserDefinedValueDeclaredConstant) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}

	return nil
}

// String names and labels used by the MojomUnion types.
var (
	unionName_UserDefinedValue                       = "UserDefinedValue"
	unionFieldName_UserDefinedValue_EnumValue        = "EnumValue"
	unionFieldName_UserDefinedValue_DeclaredConstant = "DeclaredConstant"
)

func mojom_types_UserDefinedValue__() MojomUnion {
	return MojomUnion{
		DeclData: &DeclarationData{
			ShortName: &unionName_UserDefinedValue,
		}, Fields: []UnionField{UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_UserDefinedValue_EnumValue,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_EnumValue__,
					TypeKey: &ID_mojom_types_EnumValue__},
			},
			Tag: 0,
		}, UnionField{
			DeclData: &DeclarationData{
				ShortName: &unionFieldName_UserDefinedValue_DeclaredConstant,
			},
			Type: &TypeTypeReference{
				Value: TypeReference{Identifier: &ID_mojom_types_DeclaredConstant__,
					TypeKey: &ID_mojom_types_DeclaredConstant__},
			},
			Tag: 1,
		}},
	}
}
